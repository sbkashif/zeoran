#include "output.h"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <cstring>
#include <vector>
#include <ctime>
#include <cstdlib>
#include <map>

using namespace std;

void print_structure(atom *list, vector<int> Als, int struc, string name_zeo, string name_alg, string out_name) {
	
	int alcount, ctl;
	string fname, s;
	ofstream fout;

	fname = out_name + "/" + name_zeo + "_" + name_alg + "_" + to_string(struc) + ".cif";

    fout.open(fname.c_str());    
    if(fout.fail()) {
        cerr << "unable to open file " << fname.c_str() << " for writing" << endl;
        exit( 1 );
    }

	fout << setprecision(3) << fixed;

	// Get current date
	time_t rawtime;
	struct tm * timeinfo;
	char date_buffer[80];
	time(&rawtime);
	timeinfo = localtime(&rawtime);
	strftime(date_buffer, sizeof(date_buffer), "%Y-%m-%d", timeinfo);
	
	// Get current user name
	const char* username = getenv("USER");
	if (username == nullptr) {
		username = getenv("USERNAME"); // Windows fallback
		if (username == nullptr) {
			username = "unknown_user";
		}
	}

	fout << "data_" << name_zeo << endl << endl;

	fout << "_audit_creation_method RASPA-1.0" << endl;
	fout << "_audit_creation_date " << date_buffer << endl;
	fout << "_audit_author_name '" << username << "'" << endl << endl;

	fout << "_cell_length_a    " << a << endl;
	fout << "_cell_length_b    " << b << endl;
	fout << "_cell_length_c    " << c << endl;
	fout << "_cell_angle_alpha " << alpha << endl;
	fout << "_cell_angle_beta  " << beta << endl;
	fout << "_cell_angle_gamma " << gama << endl;
	fout << "_cell_volume      " << a*b*c << endl << endl;

	fout << "_symmetry_cell_setting          " << setting << endl;
	fout << "_symmetry_space_group_name_Hall 'P 1'" << endl;
	fout << "_symmetry_space_group_name_H-M  'P 1'" << endl;
	fout << "_symmetry_Int_Tables_number     1" << endl;

	fout << "_symmetry_equiv_pos_as_xyz 'x,y,z'" << endl << endl;

	fout << "loop_" << endl;
	fout << "_atom_site_label" << endl;
	fout << "_atom_site_type_symbol" << endl;
	fout << "_atom_site_fract_x" << endl;
	fout << "_atom_site_fract_y" << endl;
	fout << "_atom_site_fract_z" << endl;
	fout << "_atom_site_charge" << endl;

	alcount=1;

	int Tat=-1;
	for(int i=0; i<Natoms; i++) {
		if(strcmp(list[i].id,"Si") ==0 ) {
			Tat++;
			ctl=1;
			for(unsigned int j=0; j<Als.size() && ctl==1; j++) {
				if(Tat == Als[j]) {
					//Put Al
					fout << "Al" << alcount << "        Al     " << list[i].x << setw(10) << list[i].y << setw(10) << list[i].z << setw(10) << list[i].q << endl;  
					ctl=0;
					alcount++;
				}
			}
			//Put Si
			if(ctl == 1) {
				fout << list[i].at << setw(10) << list[i].id << setw(10) << list[i].x << setw(10) << list[i].y << setw(10) << list[i].z << setw(10) << list[i].q << endl;
			}
		} else {
			fout << list[i].at << setw(10) << list[i].id << setw(10) << list[i].x << setw(10) << list[i].y << setw(10) << list[i].z << setw(10) << list[i].q << endl;
		}
	}

	fout.close();
	return;
}

void print_gro_structure(atom *list, vector<int> Als, int struc, string name_zeo, string name_alg, string out_name) {
	
	int ctl;
	string fname_gro, fname_itp;
	ofstream fout_gro, fout_itp;

	// Generate output filenames
	fname_gro = out_name + "/" + name_zeo + "_" + name_alg + "_" + to_string(struc) + ".gro";
	fname_itp = out_name + "/" + name_zeo + "_" + name_alg + "_" + to_string(struc) + ".itp";

	// Open GRO file for writing
	fout_gro.open(fname_gro.c_str());    
	if(fout_gro.fail()) {
		cerr << "unable to open file " << fname_gro.c_str() << " for writing" << endl;
		exit(1);
	}

	// Open ITP file for writing
	fout_itp.open(fname_itp.c_str());    
	if(fout_itp.fail()) {
		cerr << "unable to open file " << fname_itp.c_str() << " for writing" << endl;
		exit(1);
	}

	// Set precision for coordinates
	fout_gro << fixed; // Fixed-point notation
	fout_itp << setprecision(4) << fixed;

	// Get current date and user
	time_t rawtime;
	struct tm * timeinfo;
	char date_buffer[80];
	time(&rawtime);
	timeinfo = localtime(&rawtime);
	strftime(date_buffer, sizeof(date_buffer), "%Y-%m-%d", timeinfo);
	
	const char* username = getenv("USER");
	if (username == nullptr) {
		username = getenv("USERNAME"); // Windows fallback
		if (username == nullptr) {
			username = "unknown_user";
		}
	}

	// Write GRO file header
	fout_gro << "Generated by Zeoran " << date_buffer << " by " << username << endl;
	fout_gro << setw(5) << Natoms << endl;

	// Write ITP file header
	fout_itp << "; Generated by Zeoran " << date_buffer << " by " << username << endl;
	fout_itp << "; Topology file for " << name_zeo << " zeolite structure" << endl;
	fout_itp << endl;
	fout_itp << "[ moleculetype ]" << endl;
	fout_itp << "; Name        nrexcl" << endl;
	
	// Use shortened residue name (max 5 characters for GRO format compatibility)
	string residue_name = name_zeo.length() > 5 ? name_zeo.substr(0, 5) : name_zeo;
	
	fout_itp << residue_name << "         3" << endl;
	fout_itp << endl;
	fout_itp << "[ atoms ]" << endl;
	fout_itp << ";   nr       type  resnr residue  atom   cgnr     charge       mass" << endl;

	// Define atom masses (in amu)
	map<string, double> atom_masses = {
		{"Si", 28.086},
		{"Al", 26.982},
		{"O", 15.999},
		{"H", 1.008}
	};

	double total_charge = 0.0;

	int Tat = -1;
	for(int i = 0; i < Natoms; i++) {
		string atom_type;
		double charge, mass;
		
		if(strcmp(list[i].id, "Si") == 0) {
			Tat++;
			ctl = 1;
			for(unsigned int j = 0; j < Als.size() && ctl == 1; j++) {
				if(Tat == Als[j]) {
					// Replace Si with Al
					atom_type = "Al";
					charge = list[i].q; // Use the charge from the atom structure
					mass = atom_masses["Al"];
					ctl = 0;
				}
			}
			// Keep as Si
			if(ctl == 1) {
				atom_type = "Si";
				charge = list[i].q;
				mass = atom_masses["Si"];
			}
		} else {
			atom_type = string(list[i].id);
			charge = list[i].q;
			mass = atom_masses.count(atom_type) ? atom_masses[atom_type] : 1.0;
		}

		total_charge += charge;

		// Write GRO file line
		// GROMACS GRO format: "%5d%-5s%5s%5d%8.3f%8.3f%8.3f%8.4f%8.4f%8.4f"
		// residue_number(5) residue_name(5) atom_name(5) atom_number(5) x(8.3) y(8.3) z(8.3) vx(8.4) vy(8.4) vz(8.4)
		// Convert fractional coordinates to Cartesian, then Angstrom to nm
		double x_nm = list[i].x * a / 10.0;  // Convert Angstrom to nm
		double y_nm = list[i].y * b / 10.0;
		double z_nm = list[i].z * c / 10.0;
		
		// Use a short residue name (max 5 chars)
		string residue_name = name_zeo.length() > 5 ? name_zeo.substr(0, 5) : name_zeo;
		
		// Use residue number 1 for all atoms (single residue)
		int residue_number = 1;
		
		// Format: residue_number(5) residue_name(-5) atom_name(5) atom_number(5) x(8.3) y(8.3) z(8.3) [velocities]
		fout_gro << setw(5) << residue_number 
				 << left << setw(5) << residue_name 
				 << right << setw(5) << atom_type 
				 << setw(5) << (i + 1)
				 << setprecision(3) << fixed
				 << setw(8) << x_nm 
				 << setw(8) << y_nm 
				 << setw(8) << z_nm
				 << setprecision(4) << fixed
				 << setw(8) << 0.0000  // vx (nm/ps)
				 << setw(8) << 0.0000  // vy (nm/ps)
				 << setw(8) << 0.0000  // vz (nm/ps)
				 << endl;

		// Write ITP file line (use shortened residue name)
		fout_itp << setw(6) << (i + 1) << " " << left << setw(10) << atom_type 
				 << " " << setw(5) << 1 << " " << setw(7) << residue_name 
				 << " " << setw(5) << atom_type << " " << setw(5) << (i + 1)
				 << " " << right << setw(10) << charge << " " << setw(10) << mass << endl;
	}

	// Write GRO box dimensions (convert from Angstrom to nm)
	fout_gro << setw(10) << (a / 10.0) << setw(10) << (b / 10.0) << setw(10) << (c / 10.0) << endl;

	// Write ITP file footer with total charge info
	//fout_itp << endl;
	//fout_itp << "; Total charge: " << total_charge << endl;

	fout_gro.close();
	fout_itp.close();
	
	cout << "Generated GRO file: " << fname_gro << endl;
	cout << "Generated ITP file: " << fname_itp << endl;
	cout << "Total system charge: " << total_charge << endl;
	
	return;
}
